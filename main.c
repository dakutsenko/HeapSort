/*  _   _                                 _
 * | | | | ___  __ _ _ __  ___  ___  _ __| |_
 * | |_| |/ _ \/ _` | '_ \/ __|/ _ \| '__| __|
 * |  _  |  __/ (_| | |_) \__ \ (_) | |  | |_
 * |_| |_|\___|\__,_| .__/|___/\___/|_|   \__|
 *                  |_|
 *
 * Пирамидальная сортировка (Heapsort).
 *
 * Алгоритм упорядочения массива элементов по неубыванию.
 *
 * Автор алгоритма: Билл Уильямс, 1964 г.
 *
 * Williams, J. W. J. 
 * Algorithm 232: Heapsort //
 * Communication of the ACM. - 1964. - Vol. 7, No. 6. - P. 347-348.
 * doi:10.1145/512274.512284
 *
 * Может рассматриваться как улучшенная сортировка выбором (selection sort).
 *
 * Достоинства алгоритма:
 * 1. В худшем, среднем и в лучшем случае работает за O(n log n) операций
 *    при сортировке n элементов.
 * 2. Количество дополнительной памяти не зависит от n, т. е. равно O(1).
 *
 * Недостатки алгоритма:
 * 1. Сложен в реализации.
 * 2. Неустойчив (может менять относительный порядок элементов,
 *    имеющих одинаковые ключи).
 * 3. На почти отсортированных массивах работает столь же долго,
 *    как и на хаотических данных.
 * 4. На одном шаге выборку приходится делать хаотично
 *    по всей длине массива, поэтому алгоритм плохо сочетается
 *    с кэшированием и подкачкой памяти.
 * 5. Не работает на связанных списках
 *    и других структурах памяти последовательного доступа.
 *
 * Алгоритм основан на представлении неотсортированной части массива
 * в виде пирамиды.
 *
 * Пирамида (heap, двоичная куча, сортирующее дерево) - двоичное дерево,
 * удовлетворяющее следующим условиям:
 * 1. Значение в любой вершине не меньше, чем значения её потомков.
 * 2. Глубина листьев (расстояние до корня) отличается не более,
 *    чем на 1 уровень.
 *
 * Удобная структура данных для пирамиды - массив a[1..n],
 * в котором a[1] - корневой элемент,
 * содержащий максимальный элемент в массиве,
 * потомки элемента a[i] - это a[2*i] и a[2*i + 1],
 * причём a[i] >= a[2*i] и a[i] >= a[2*i + 1] для всех 1 <= i < n/2.
 *
 * Алгоритм пирамидальной сортировки массива a[1..n]:
 * 1. Построить пирамиду на массиве a;
 * 2. Для каждого k = n..1 выполнить следующие действия:
 * 2.1. Поменять местами корневой элемент a[1] и элемент a[k];
 * 2.2. Уменьшить на 1 размер пирамиды;
 * 2.3. Восстановить пирамиду после замены корневого элемента,
 *      просеяв вниз новый корневой элемент;
 * 2.4. (Конец цикла по k);
 */

#include <stdio.h>
#include <assert.h>

/* Тип элемента массива (может быть сложной структурой) */
typedef int Item;
/* Строка формата для вывода элемента */
#define ITEM_F "%d"
/* Поля элемента a, используемые для его вывода */
#define ELEM(a) (a)
/* Приоритет элемента a меньше, чем приоритет элемента b */
#define LESS(a, b) ((a) < (b))
/* Обменять местами элементы a и b */
void exch(Item *a, Item *b) {
	Item t = *a;
	*a = *b;
	*b = t;
}
/* Вывести на экран элементы массива a[0..N-1] */
void print_array(Item a[], const int N) {
	int i;
	for (i = 0; i < N; ++i) {
		printf(ITEM_F "%s", ELEM(a[i]), (i < N - 1) ? " " : "\n");
	}
}

/* Просеивание вниз.
 * Восстановить пирамидальную структуру сортирующего дерева размера n
 * в случае, когда узел в позиции k может быть меньше,
 * чем один или оба из его потомков */
void fix_down(Item a[], int k, int n) {
	/* Алгоритм восстановления пирамиды:
	 * Двигаться вниз по сортирующему дереву,
	 * меняя при необходимости местами узел в позиции k
	 * с бОльшим из его двух потомков
	 * (которые расположены в позициях 2*k и 2*k+1).
	 * Остановиться, когда узел в позиции k не превышает
	 * какой-либо из его двух потомков,
	 * либо когда достигнут нижний уровень дерева */
	int j;
	/* Пока не достигнут нижний уровень сортирующего дерева: */
	while (2 * k <= n) {
		/* Вычислить позицию левого потомка узла k */
		j = 2 * k;
		/* Если не достигнут конец массива и правый потомок больше левого: */
		if (j < n && LESS(a[j], a[j + 1])) {
			/* Использовать правого потомка вместо левого */
			++j;
		}
		/* Элемент в позиции k не меньше, чем его потомки */
		if (!LESS(a[k], a[j])) {
			/* Выйти из цикла, так как пирамида построена правильно */
			break;
		}
		/* Поменять местами потомка и родителя */
		exch(&a[k], &a[j]);
		/* Продолжить просеивание вниз */
		k = j;
	}
}

/* Выполнить пирамидальную сортировку с l-того по r-тый элемент массива a */
void heapsort(Item a[], int l, int r) {
	/* Вычислить размер пирамиды */
	int n = r - l + 1;
	/* Указатель h использовать как массив h[1..n],
	 * содержащий пирамиду с корнем в h[1].
	 * Если l = 0, то h может указывать на a[-1]! */
	Item *h = &a[l - 1];
	int k;

	/* Предусловие: позиция l не больше r */
	assert(l <= r);
	/* Преобразовать массив в пирамиду просеиванием вниз */
	for (k = n / 2; k >= 1; --k) {
		fix_down(h, k, n);
	}
	/* Сортировать массив, выбирая максимальный элемент, 
	 * который находится в корне пирамиды,
	 * пока пирамида не станет пустой */
	while (n > 1) {
		/* Обменять местами наибольший элемент (находится в корне)
		 * с последним элементом пирамиды */
		exch(&h[1], &h[n]);
		/* Уменьшить размер пирамиды */
		--n;
		/* Восстановить свойства пирамиды после удаления корня,
		 * просеяв вниз новый корневой элемент */
		fix_down(h, 1, n);
	}
}

/* Основная программа для проверки сортировки */
int main() {
	/* Массив для сортировки */
	Item a[] = {2, 0, 7, 9, 5, 3, 6};
	/* Количество элементов в массиве */
	const int N = sizeof(a) / sizeof(a[0]);

	printf("Исходный массив:\n\t");
	print_array(a, N);

	/* Сортировка: */
	heapsort(a, 0, N - 1);

	printf("Отсортированный массив:\n\t");
	print_array(a, N);

	return 0;
}
